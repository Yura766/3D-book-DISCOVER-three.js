figure > cube this project:

`MeshBasicMaterial` - найпростіший матеріал, доступний у three.js. Він зовсім не реагує на світло, а вся поверхня сітки затінена одним кольором. Затінення на основі кута огляду чи відстані не виконується, тому об’єкт навіть не виглядає тривимірним. Все, що ми бачимо, це 2D контур.

`MeshStandardMaterial` - У цій главі ми замінимо основний матеріал на MeshStandardMaterial. Це високоякісний, універсальний, фізично точний матеріал, який реагує на світло за допомогою фізичних рівнянь реального світу. Як випливає з назви, MeshStandardMaterialце має бути ваш «стандартний» матеріал для майже всіх ситуацій. З додаванням добре опрацьованих текстур ми можемо відтворити майже будь-яку поширену поверхню за допомогою MeshStandardMaterial.

1.2 
Перш ніж почати роботу з кодом, давайте розглянемо основні компоненти, які складають кожну програму three.js. По-перше, це сцена, камера та рендерер, які утворюють базову основу програми. Далі є `<canvas>`елемент HTML , де ми бачимо результати. І останнє, але не менш важливе, є видимий об’єкт, наприклад сітка. За винятком полотна (яке є специфічним для браузера), еквівалент кожного з цих компонентів можна знайти в будь-якій 3D-графічній системі, що робить знання, які ви отримаєте на цих сторінках, зручними для передачі.

1.4
Ми не можемо говорити про одне без іншого, тому в цьому розділі ми також представляємо нове світло: `DirectionalLight`. Цей тип світла імітує промені від далекого джерела світла, наприклад сонця. Далі в книзі ми детальніше дослідимо, як взаємодіють світло та матеріали. Щоб використовувати матеріали PBR, такі як `MeshStandardMaterial`, ми повинні додати світло до сцени. Це має сенс - якщо немає світла, ми не можемо бачити. Те, що `MeshBasicMaterialми` використовували досі, не має фізичної основи та не вимагає освітлення.

Щоб увімкнути фізично правильне освітлення, просто ввімкніть параметр рендерера `.physicallyCorrectLights`:

Цей параметр вимкнено за умовчанням, щоб підтримувати зворотну сумісність. Однак увімкнення не має недоліків, тому ми завжди вмикаємо його. Є ще кілька параметрів, які нам потрібно налаштувати, щоб кольори та освітлення працювали фізично правильно. Однак, увімкнувши цей параметр, ми зробили важливий перший крок до виробничого, фізично точного освітлення в наших сценах.

1  одиниця=1  метр
Якщо ви приносите моделі, створені іншим художником, які вимірюються у футах, дюймах, сантиметрах або стадіях, вам слід змінити масштаб їх на метри. У наступному розділі ми покажемо вам, як масштабувати об’єкти .

Якщо ввімкнути лампочку в темній кімнаті, предмети в цій кімнаті отримають світло двома способами:

Пряме освітлення : світлові промені, які виходять безпосередньо від лампочки і потрапляють на предмет.
Непряме освітлення : світлові промені, які відбиваються від стін та інших об’єктів у кімнаті перед тим, як потрапити на об’єкт, змінюють колір і втрачають інтенсивність із кожним відбиттям.
Відповідно до них класи легких у three.js поділяються на два типи:

Прямі світильники , які імітують пряме освітлення.
Навколишнє освітлення , яке є дешевим і дещо правдоподібним способом імітації непрямого освітлення.

Пряме освітлення #
У цьому розділі ми додамо `DirectionalLight`, який імітує світло від сонця або іншого дуже яскравого далекого джерела.

`DirectionalLight`=> Сонячне світло

`PointLight`=> Лампочки

`RectAreaLight`=> Смугове освітлення або яскраві вікна

`SpotLight`=> Точкові світильники

1.5 Щоразу, коли ми переміщуємо об’єкти в 3D-просторі, ми робимо це за допомогою математичних операцій, які називаються перетвореннями . Ми вже бачили два типи трансформації: переміщення , що зберігається у властивості об’єкта `.position`, і обертання , що зберігається у `.rotation` властивості. Разом із масштабуванням , що зберігається у `.scale` властивості, вони складають три фундаментальні перетворення, які ми будемо використовувати для переміщення об’єктів у наших сценах. Іноді ми будемо посилатися на перетворення, обертання та масштабування, використовуючи їхні ініціали, `TRS` .

Кожен об’єкт, за допомогою якого ми можемо додати до сцени, scene.addмає ці властивості


Додавати нову модель можна до любої сцени як світової так і отримати об'єкттну 
// A starts at (0,0,0) in world space
scene.add(meshA);

// B starts at (0,0,0) in A's local space
meshA.add(meshB);

meshA.position.x = 5;

meshB.position.x = 3;



Положення об'єкта наX-вісь, яку назвемо X.
Положення об'єкта наY-вісь, яку назвемо Y.
Положення об'єкта наZ-вісь, яку назвемо Z.
Ми можемо записати ці три позиції у вигляді впорядкованого списку чисел:( x ,y ,z ).



1.6 згладжування ( AA ).

в цій статті є рендеринг сцени і при змінні ширини/висоти об'екта 
і
фікс коли об'єкт міняється свій розмір непропорціонально   

![нерівності при маштабуванні](https://discoverthreejs.com/images/first-steps/antialias.svg)

Увімкнути згладжування 
  const renderer = new WebGLRenderer({ antialias: true });


































Замітки:
- .position, .rotation, .scale

- можна обекту задати

- cube.position.x = -0.5;
  cube.position.y = -0.1;
  cube.position.z = 1;

  // equivalent to:
  // cube.position.set(-0.5, -0.1, 1);

  cube.scale.x = 1.25;
  cube.scale.y = 0.25;
  cube.scale.z = 0.5;

  // equivalent to:
  // cube.scale.set(1.25, 0.25, 0.5);

![Позиції в просторі](https://discoverthreejs.com/images/first-steps/coordinate_system_simple.svg)